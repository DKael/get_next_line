# 📖 get_next_line

42서울 C 언어 커리큘럼의 대표적인 시스템 프로그래밍 과제로, 파일 디스크립터(fd)로부터 텍스트를 한 줄씩 읽어오는 함수를 직접 구현하는 프로젝트입니다.
Bonus 버전에서는 여러 개의 파일 디스크립터를 동시에 처리할 수 있도록 확장되었습니다.

---

## 1️⃣ 프로젝트 소개

get_next_line은 텍스트 파일, 표준 입력, 파이프 등 다양한 입력 소스로부터 한 번에 한 줄씩 데이터를 읽어오는 함수를 직접 구현하는 프로젝트입니다.
Bonus 버전은 fd별로 독립적인 상태 관리를 수행하여, 동시에 여러 파일을 열어놓고 줄 단위로 읽는 기능을 제공합니다.

---

## 2️⃣ 과제 목표
	•	파일 디스크립터에서 데이터를 한 줄 단위로 읽어오는 함수 구현
	•	여러 개의 파일 디스크립터를 동시에 처리할 수 있는 기능 확장
	•	버퍼 기반 입출력과 정적 변수 활용 심화
	•	다양한 edge case 처리 능력 강화 (EOF, 빈 줄, 줄바꿈 없는 파일 등)

---

## 3️⃣ 구현 사항
* get_next_line(int fd)
    - 호출될 때마다 해당 fd의 다음 줄을 반환
    - 파일 끝에서는 NULL 반환
* 멀티 fd 지원
    - 내부적으로 fd별 저장소(예: 배열, 연결 리스트)를 유지해 독립적인 상태 관리
    - fd1, fd2 등 여러 개의 파일을 동시에 읽는 경우에도 정상 동작
    - fd 값이 '0'일 경우 사용자로부터 직접 입력받기
* BUFFER_SIZE 매크로를 활용해 버퍼 크기 조절 가능
* 메모리 누수 방지를 위한 동적 할당 및 해제 처리

---

## 4️⃣ 다른 learner들과의 구현 상의 차별점
대부분의 학습자들은 큰 배열을 한 번 할당한 뒤, 그 안에서 문자열을 옮기는 방식으로 구현했습니다. 예를 들어, 줄바꿈 문자를 찾아서 처음부터 줄바꿈 문자까지의 내용을 반환하고 줄바꿈 이후의 문자를 배열의 처음으로 옮기는 (예시로 배열의 10000번 인덱스에서 시작하는 5000글자 문자열을 0번 인덱스로 이동) 것입니다.

반면 저는 **연결 리스트(linked list)**를 활용하여 이러한 불필요한 문자열 복사를 최소화하려고 했습니다. 이 방식을 통해 줄 단위 데이터를 효율적으로 관리할 수 있도록 하였습니다.

다만, 작성 시점에서 돌아보면 메모리를 자주 할당하는 비용이 문자열 이동보다 더 큰 오버헤드를 유발할 수도 있다는 생각이 들었습니다. 특히 시스템 콜 호출이나 캐시 미스(cache miss) 문제에서 성능 차이가 발생할 수 있으므로, 두 방식에 대한 정량적인 성능 비교 검증이 필요하다고 생각합니다.

---

## 5️⃣ 배운 점
	•	시스템 콜 read의 사용법과 동작 메커니즘 이해
	•	포인터, 동적 메모리, 문자열 처리 심화 학습
	•	정적 변수(static variable)를 이용한 상태 유지 방법
	•	파일 입출력과 버퍼링의 중요성에 대한 체감
	•	edge case(빈 파일, 긴 줄, 줄바꿈 없는 파일 등) 처리 경험

---

## 6️⃣ 사용 방법

### 🛠️ 빌드
```
    make
```
➡️ 결과물: libgnl.a 정적 라이브러리 생성

## 📌 예시 실행

main.c와 함께 컴파일 후 실행:
```
  #include <fcntl.h>
  #include <stdio.h>
  #include "get_next_line.h"
  
  int main(void)
  {
      int fd = open("test.txt", O_RDONLY);
      char *line;
  
      while ((line = get_next_line(fd)) != NULL)
      {
          printf("%s", line);
          free(line);
      }
      close(fd);
      return 0;
  }
```
컴파일 및 실행:
```
    gcc main.c -L. -lgnl -o main
    ./main
```

---

## 7️⃣ 기술 스택
	•	언어: C
 	•	운영체제/환경: Unix/Linux
 	•	빌드 도구: GNU Make
 	•	Coding Conventions: Norminette
	•	시스템 콜: read

---

## 8️⃣ 유의 사항
42의 코딩 규칙인 Norminette과 과제의 제한 사항(제출 가능한 파일 수 제한)으로 인해 코드 작성에 여러 제약이 있었습니다.
  * 한 줄당 최대 80자
  * 함수당 최대 25줄
  * 한 파일에 최대 5개의 함수
  * 제출 가능한 파일 수는 최대 2개
  * 25 * 5 * 2 = 250줄, 250줄 이내에 작성

이 조건 속에서 연결 리스트를 사용해 과제의 요구사항을 구현하다 보니, 코드의 가독성이 좋은 편은 아닙니다.
